// Cloudflare Worker - Anthropic API Proxy + Whoop OAuth Handler
// Handles both Claude API requests and Whoop API authentication/data fetching

export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, x-api-key, Authorization',
          'Access-Control-Max-Age': '86400',
        }
      });
    }

    // Route: Whoop OAuth Token Exchange
    if (url.pathname === '/whoop/token' && request.method === 'POST') {
      return handleWhoopTokenExchange(request);
    }

    // Route: Whoop Data Fetch
    if (url.pathname === '/whoop/data' && request.method === 'POST') {
      return handleWhoopDataFetch(request);
    }

    // Route: Claude API Proxy (existing)
    if (request.method === 'POST') {
      return handleClaudeProxy(request);
    }

    return new Response('Method not allowed', { status: 405 });
  }
};

// Whoop Configuration
const WHOOP_CONFIG = {
  clientId: '8bd2a955-6f43-4cf1-90d0-806819258104',
  clientSecret: 'fbe88f7f3874c77bbcb5f3f167699397ba47e9ae3b884ce2403c11fc184f3eee',
  redirectUri: 'https://ptonagh.github.io/fndtn-tracker/callback.html',
  tokenUrl: 'https://api.prod.whoop.com/oauth/oauth2/token',
  apiBaseUrl: 'https://api.prod.whoop.com/developer'
};

// Handle Whoop OAuth token exchange
async function handleWhoopTokenExchange(request) {
  try {
    const { code } = await request.json();

    if (!code) {
      return corsResponse({ error: 'Authorization code required' }, 400);
    }

    // Exchange code for access token
    const tokenResponse = await fetch(WHOOP_CONFIG.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        client_id: WHOOP_CONFIG.clientId,
        client_secret: WHOOP_CONFIG.clientSecret,
        redirect_uri: WHOOP_CONFIG.redirectUri
      })
    });

    const tokenData = await tokenResponse.json();

    if (!tokenResponse.ok) {
      console.error('Whoop token error:', tokenData);
      return corsResponse({ error: tokenData.error || 'Token exchange failed' }, tokenResponse.status);
    }

    // Return tokens to client
    return corsResponse({
      access_token: tokenData.access_token,
      refresh_token: tokenData.refresh_token,
      expires_in: tokenData.expires_in
    });

  } catch (error) {
    console.error('Token exchange error:', error);
    return corsResponse({ error: error.message }, 500);
  }
}

// Handle Whoop data fetching
async function handleWhoopDataFetch(request) {
  try {
    const { access_token } = await request.json();

    if (!access_token) {
      return corsResponse({ error: 'Access token required' }, 401);
    }

    // Fetch latest recovery cycle (v2 API)
    const recoveryResponse = await fetch(`${WHOOP_CONFIG.apiBaseUrl}/v2/recovery`, {
      headers: {
        'Authorization': `Bearer ${access_token}`
      }
    });

    if (!recoveryResponse.ok) {
      const errorText = await recoveryResponse.text();
      console.error('Recovery fetch failed:', recoveryResponse.status, errorText);

      // If token expired, return specific error
      if (recoveryResponse.status === 401) {
        return corsResponse({
          error: 'token_expired',
          message: 'Access token expired. Please reconnect Whoop.'
        }, 401);
      }

      return corsResponse({ error: `Recovery fetch failed: ${errorText}` }, recoveryResponse.status);
    }

    const recoveryData = await recoveryResponse.json();
    console.log('Recovery data:', recoveryData);

    // Fetch latest sleep data (v2 API)
    const sleepResponse = await fetch(`${WHOOP_CONFIG.apiBaseUrl}/v2/activity/sleep`, {
      headers: {
        'Authorization': `Bearer ${access_token}`
      }
    });

    if (!sleepResponse.ok) {
      const errorText = await sleepResponse.text();
      console.error('Sleep fetch failed:', sleepResponse.status, errorText);
    }

    const sleepData = await sleepResponse.json();
    console.log('Sleep data:', sleepData);

    // Extract the most recent records
    const latestRecovery = recoveryData.records?.[0] || {};
    const latestSleep = sleepData.records?.[0] || {};

    console.log('Latest recovery:', JSON.stringify(latestRecovery));
    console.log('Latest sleep:', JSON.stringify(latestSleep));

    // Debug: Log all sleep_needed fields to understand Whoop's calculation
    const sleepNeeded = latestSleep.score?.sleep_needed || {};

    // Calculate different possible "debt" values
    const rawDebt = Math.round((sleepNeeded.need_from_sleep_debt_milli || 0) / 60000);
    const debtWithNaps = Math.round(((sleepNeeded.need_from_sleep_debt_milli || 0) + (sleepNeeded.need_from_recent_nap_milli || 0)) / 60000);
    const totalAboveBaseline = Math.round(((sleepNeeded.need_from_sleep_debt_milli || 0) + (sleepNeeded.need_from_recent_strain_milli || 0) + (sleepNeeded.need_from_recent_nap_milli || 0)) / 60000);

    // Single log with all debug info
    console.log(`
ðŸ” SLEEP DEBT DEBUG:
baseline: ${Math.round((sleepNeeded.baseline_milli || 0) / 60000)} mins
need_from_sleep_debt: ${Math.round((sleepNeeded.need_from_sleep_debt_milli || 0) / 60000)} mins
need_from_recent_strain: ${Math.round((sleepNeeded.need_from_recent_strain_milli || 0) / 60000)} mins
need_from_recent_nap: ${Math.round((sleepNeeded.need_from_recent_nap_milli || 0) / 60000)} mins
---
CALCULATIONS:
Raw debt: ${rawDebt} mins
Debt + naps: ${debtWithNaps} mins
Total above baseline: ${totalAboveBaseline} mins
Whoop shows: 37 mins - which one matches?
    `);

    // Map Whoop v2 data to our app format
    const mappedData = {
      // Sleep Performance: v2 uses sleep_performance_percentage (0-100)
      sleepPerformance: latestSleep.score?.sleep_performance_percentage || 0,

      // HRV: This is working correctly
      hrv: latestRecovery.score?.hrv_rmssd_milli || 0,

      // Sleep Debt: Testing - using raw debt for now while we debug
      // We'll see all calculations in Cloudflare logs
      sleepDebt: rawDebt,

      // Sleep Duration: Sum of actual sleep stages (light + deep + REM) in hours
      sleepDuration: (() => {
        const totalSleepMilli = (
          (latestSleep.score?.stage_summary?.total_light_sleep_time_milli || 0) +
          (latestSleep.score?.stage_summary?.total_slow_wave_sleep_time_milli || 0) +
          (latestSleep.score?.stage_summary?.total_rem_sleep_time_milli || 0)
        );
        return Math.round((totalSleepMilli / 3600000) * 10) / 10; // Convert to hours, 1 decimal
      })(),

      recoveryScore: latestRecovery.score?.recovery_score || 0,
      timestamp: new Date().toISOString()
    };

    console.log('Mapped data:', JSON.stringify(mappedData));
    return corsResponse(mappedData);

  } catch (error) {
    console.error('Whoop data fetch error:', error);
    return corsResponse({ error: error.message }, 500);
  }
}

// Handle Claude API proxy (existing functionality)
async function handleClaudeProxy(request) {
  try {
    const apiKey = request.headers.get('x-api-key');
    
    if (!apiKey) {
      return corsResponse({ error: { message: 'No API key provided' } }, 401);
    }

    const body = await request.json();

    const anthropicResponse = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify(body)
    });

    const responseData = await anthropicResponse.json();

    return corsResponse(responseData, anthropicResponse.status);

  } catch (error) {
    return corsResponse({ error: { message: error.message } }, 500);
  }
}

// Helper function to add CORS headers
function corsResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, x-api-key, Authorization'
    }
  });
}
